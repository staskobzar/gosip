package sipmsg

import (
	"slices"
	"strconv"
)

// Message represence SIP request or response messager
type Message struct {
	t      HType
	Method string
	RURI   *URI
	Code   string
	Reason string

	CallID string
	CSeq   int
	MaxFwd int
	From   *NameAddr
	To     *NameAddr

	Headers Headers
	Body    string
}

// NewMessage initiate new Message
func NewMessage() *Message {
	return &Message{
		Headers: make(Headers, 0, 32),
	}
}

// Byte returns *Message as byte
func (msg *Message) Byte() []byte { return []byte(msg.String()) }

// IsResponse returns true if Message is SIP response
func (msg *Message) IsResponse() bool { return msg.t == HResponse }

// SIPMethod returns Message method
func (msg *Message) SIPMethod() string { return msg.Method }

// ResponseCode returns SIP response code for ResponseCode or zero
func (msg *Message) ResponseCode() int {
	if !msg.IsResponse() {
		return 0
	}
	code, _ := strconv.Atoi(msg.Code)
	return code
}

// TopViaBranch returns top Via header branch parameter
func (msg *Message) TopViaBranch() string {
	hdr := msg.Find(HVia)
	if hdr == nil {
		return ""
	}

	via, ok := hdr.(*HeaderVia)
	if !ok {
		return ""
	}

	return via.Branch
}

// ACK returns ACK message generated from initial request
// This ACK request is a part of transaction machine
// and generated on any responses other then 200
// ACK for 200 responses are generated by TU/UA level
//
// 17.1.1.3 Construction of the ACK Request
// ACK is supposed to be generated from initial request
func (msg *Message) ACK(resp *Message) *Message {
	ack := NewMessage()
	ack.t = HRequest
	ack.Method = "ACK"
	ack.RURI = msg.RURI

	ack.Append(HGeneric, msg.Find(HVia))
	ack.MaxFwd = 70
	ack.Append(HGeneric, &HeaderGeneric{T: HMaxForwards, HeaderName: "Max-Forwards", Value: "70"})

	for _, r := range msg.FindAll(HRoute) {
		ack.Append(HGeneric, r)
	}

	ack.From = msg.From
	ack.Append(HGeneric, ack.From)

	ack.To = resp.To
	ack.Append(HGeneric, ack.To)

	ack.CallID = msg.CallID
	ack.Append(HGeneric, &HeaderGeneric{T: HCallID, HeaderName: "Call-ID", Value: msg.CallID})

	ack.CSeq = msg.CSeq
	ack.Append(HGeneric, &HeaderGeneric{T: HCSeq, HeaderName: "CSeq", Value: strconv.Itoa(msg.CSeq) + " ACK"})

	ack.Append(HGeneric, &HeaderGeneric{T: HContentLength, HeaderName: "Content-Length", Value: "0"})

	return ack
}

// Append SIP Header to Message. Will search for the first accurence
// of t type header and append header after. If t is HGeneric or
// header not found then append to the last header
func (msg *Message) Append(t HType, hdr AnyHeader) {
	msg.push(t, hdr,
		func() []AnyHeader { return append(msg.Headers, hdr) },
		func(i int) int { return i + 1 })
}

// Insert SIP Header to Message. Will search for the first accurence
// of t type header and insert header before it. If t is HGeneric or
// header not found then insert to the top
func (msg *Message) Insert(t HType, hdr AnyHeader) {
	msg.push(t, hdr,
		func() []AnyHeader { return slices.Insert(msg.Headers, 0, hdr) },
		func(i int) int { return i })
}

func (msg *Message) push(t HType, hdr AnyHeader, gen func() []AnyHeader, index func(int) int) {
	if t == HGeneric {
		msg.Headers = gen()
		return
	}

	for i, h := range msg.Headers {
		if h.Type() == t {
			msg.Headers = slices.Insert(msg.Headers, index(i), hdr)
			return
		}
	}

	// not found
	msg.Headers = gen()
}

// HLen returns number of headers in the SIP message
func (msg *Message) HLen() int { return msg.Headers.Len() }

// Find first occurrense of a header by HType
func (msg *Message) Find(t HType) AnyHeader {
	return msg.find(func(h AnyHeader) bool { return h.Type() == t })
}

// FindAll find and return list of headers by type
func (msg *Message) FindAll(t HType) Headers {
	return msg.findAll(func(h AnyHeader) bool { return h.Type() == t })
}

// FindByName first occurrense of a header by name
func (msg *Message) FindByName(name string) AnyHeader {
	return msg.find(func(h AnyHeader) bool { return h.Name() == name })
}

// FindByNameAll find and return list of headers by name
func (msg *Message) FindByNameAll(name string) Headers {
	return msg.findAll(func(h AnyHeader) bool { return h.Name() == name })
}

func (msg *Message) Len() int {
	crln := 2
	l := 9 // "SIP/2.0" + spaces
	if msg.t == HRequest {
		l += len(msg.Method) + msg.RURI.Len()
	} else {
		l += len(msg.Code) + len(msg.Reason)
	}
	l += crln

	for _, hdr := range msg.Headers {
		l += hdr.Len() + crln
	}
	return l + crln + len(msg.Body)
}

// String return Message as string
func (msg *Message) String() string {
	buf := NewStringer(msg.Len())

	msg.firstLine(buf)

	for _, hdr := range msg.Headers {
		hdr.Stringify(buf)
		buf.Print("\r\n")
	}

	buf.Print("\r\n", msg.Body)

	return buf.String()
}

func (msg *Message) firstLine(buf *Stringer) {
	if msg.IsResponse() {
		buf.Print("SIP/2.0 ", msg.Code, " ", msg.Reason, "\r\n")
		return
	}
	buf.Print(msg.Method, " ")
	msg.RURI.Stringify(buf)
	buf.Print(" SIP/2.0\r\n")
}

func (msg *Message) find(match func(h AnyHeader) bool) AnyHeader {
	for _, h := range msg.Headers {
		if match(h) {
			return h
		}
	}
	return nil
}

func (msg *Message) findAll(match func(h AnyHeader) bool) Headers {
	list := make(Headers, 0)
	for _, h := range msg.Headers {
		if match(h) {
			list = append(list, h)
		}
	}
	return list
}

func (msg *Message) pushHeader(t HType, name, value string) {
	generic := &HeaderGeneric{
		T:          t,
		HeaderName: name,
		Value:      value,
	}
	msg.Headers = append(msg.Headers, generic)
}
