package sipmsg

import (
	"gosip/pkg/sip"
	"slices"
	"strconv"
	"strings"
)

// Message represence SIP request or response messager
type Message struct {
	t      HType
	Method string
	RURI   *URI
	Code   string
	Reason string

	CallID string
	CSeq   int
	MaxFwd int
	From   *NameAddr
	To     *NameAddr

	Headers Headers
	Body    string
}

// NewMessage initiate new Message
func NewMessage() *Message {
	return &Message{
		Headers: make(Headers, 0, 32),
	}
}

// Byte returns *Message as byte
// @impl sip.Message
func (msg *Message) Byte() []byte { return []byte(msg.String()) }

// IsResponse returns true if Message is SIP response
// @impl sip.Message
func (msg *Message) IsResponse() bool { return msg.t == HResponse }

// SIPMethod returns Message method
// @impl sip.Message
func (msg *Message) SIPMethod() string { return msg.Method }

// ResponseCode returns SIP response code for ResponseCode or zero
// @impl sip.Message
func (msg *Message) ResponseCode() int {
	if !msg.IsResponse() {
		return 0
	}
	code, _ := strconv.Atoi(msg.Code)
	return code
}

// TopViaBranch returns top Via header branch parameter
// @impl sip.Message
func (msg *Message) TopViaBranch() string {
	hdr := msg.Find(HVia)
	if hdr == nil {
		return ""
	}

	via, ok := hdr.(*HeaderVia)
	if !ok {
		return ""
	}

	return via.Branch
}

// Ack returns ACK message generated from initial request
// @impl sip.Message
func (msg *Message) Ack(resp sip.Message) sip.Message {
	return msg.ACK(resp.(*Message))
}

// Ack returns ACK message generated from initial request
// This ACK request is a part of transaction machine
// and generated on any responses other then 200
// ACK for 200 responses are generated by TU/UA level
//
// 17.1.1.3 Construction of the ACK Request
// ACK is supposed to be generated from initial request
// @impl sip.Message
func (msg *Message) ACK(resp *Message) *Message {
	ack := NewMessage()
	ack.t = HRequest
	ack.Method = "ACK"
	ack.RURI = msg.RURI

	ack.Append(HGeneric, msg.Find(HVia))
	ack.MaxFwd = 70
	ack.Append(HGeneric, &HeaderGeneric{T: HMaxForwards, HeaderName: "Max-Forwards", Value: "70"})

	for _, r := range msg.FindAll(HRoute) {
		ack.Append(HGeneric, r)
	}

	ack.From = msg.From
	ack.Append(HGeneric, ack.From)

	ack.To = resp.To
	ack.Append(HGeneric, ack.To)

	ack.CallID = msg.CallID
	ack.Append(HGeneric, &HeaderGeneric{T: HCallID, HeaderName: "Call-ID", Value: msg.CallID})

	ack.CSeq = msg.CSeq
	ack.Append(HGeneric, &HeaderGeneric{T: HCSeq, HeaderName: "CSeq", Value: strconv.Itoa(msg.CSeq) + " ACK"})

	ack.Append(HGeneric, &HeaderGeneric{T: HContentLength, HeaderName: "Content-Length", Value: "0"})

	return ack
}

// Append SIP Header to Message. Will search for the first accurence
// of t type header and append header after. If t is HGeneric or
// header not found then append to the last header
func (msg *Message) Append(t HType, hdr AnyHeader) {
	msg.push(t, hdr,
		func() []AnyHeader { return append(msg.Headers, hdr) },
		func(i int) int { return i + 1 })
}

// Insert SIP Header to Message. Will search for the first accurence
// of t type header and insert header before it. If t is HGeneric or
// header not found then insert to the top
func (msg *Message) Insert(t HType, hdr AnyHeader) {
	msg.push(t, hdr,
		func() []AnyHeader { return slices.Insert(msg.Headers, 0, hdr) },
		func(i int) int { return i })
}

func (msg *Message) push(t HType, hdr AnyHeader, gen func() []AnyHeader, index func(int) int) {
	if t == HGeneric {
		msg.Headers = gen()
		return
	}

	for i, h := range msg.Headers {
		if h.Type() == t {
			msg.Headers = slices.Insert(msg.Headers, index(i), hdr)
			return
		}
	}

	// not found
	msg.Headers = gen()
}

// HLen returns number of headers in the SIP message
func (msg *Message) HLen() int { return msg.Headers.Len() }

// Find first occurrense of a header by HType
func (msg *Message) Find(t HType) AnyHeader {
	return msg.find(func(h AnyHeader) bool { return h.Type() == t })
}

// FindAll find and return list of headers by type
func (msg *Message) FindAll(t HType) Headers {
	return msg.findAll(func(h AnyHeader) bool { return h.Type() == t })
}

// FindByName first occurrense of a header by name
func (msg *Message) FindByName(name string) AnyHeader {
	return msg.find(func(h AnyHeader) bool { return h.Name() == name })
}

// FindByNameAll find and return list of headers by name
func (msg *Message) FindByNameAll(name string) Headers {
	return msg.findAll(func(h AnyHeader) bool { return h.Name() == name })
}

// String return Message as string
func (msg *Message) String() string {
	buf := make([]string, 0, msg.HLen()+1)
	buf = append(buf, msg.firstLine())

	for _, hdr := range msg.Headers {
		buf = append(buf, hdr.String())
	}

	return strings.Join(buf, "\r\n") + "\r\n\r\n" + msg.Body
}

func (msg *Message) firstLine() string {
	if msg.t == HRequest {
		return msg.Method + " " + msg.RURI.String() + " SIP/2.0"
	}
	return "SIP/2.0 " + msg.Code + " " + msg.Reason
}

func (msg *Message) find(match func(h AnyHeader) bool) AnyHeader {
	for _, h := range msg.Headers {
		if match(h) {
			return h
		}
	}
	return nil
}

func (msg *Message) findAll(match func(h AnyHeader) bool) Headers {
	list := make(Headers, 0)
	for _, h := range msg.Headers {
		if match(h) {
			list = append(list, h)
		}
	}
	return list
}

func (msg *Message) pushHeader(t HType, name, value string) {
	generic := &HeaderGeneric{
		T:          t,
		HeaderName: name,
		Value:      value,
	}
	msg.Headers = append(msg.Headers, generic)
}
