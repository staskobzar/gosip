package sipmsg

import (
	"errors"
	"fmt"
	"net"
	"slices"
	"strconv"
	"strings"
)

var (
	Error   = errors.New("SIP Message")
	ErrCopy = errors.New("sipmsg header copy")
)

// Message represence SIP request or response messager
type Message struct {
	t      HType
	Method string
	RURI   *URI
	Code   string
	Reason string

	CallID string
	CSeq   int
	MaxFwd int
	From   *NameAddr
	To     *NameAddr

	Headers Headers
	Body    string
}

// NewMessage initiate new Message
func NewMessage() *Message {
	return &Message{
		Headers: make(Headers, 0, 32),
	}
}

// Byte returns *Message as byte
func (msg *Message) Byte() []byte { return []byte(msg.String()) }

// IsInvite returns true if message is request and method is INVITE
func (msg *Message) IsInvite() bool { return msg.IsMethod("INVITE") }

// IsMethod case-insensitive method compare to given string
func (msg *Message) IsMethod(method string) bool { return strings.EqualFold(msg.Method, method) }

// IsResponse returns true if Message is SIP response
func (msg *Message) IsResponse() bool { return msg.t == HResponse }

// IsRequest just a small helper for better code readability
func (msg *Message) IsRequest() bool { return !msg.IsResponse() }

// SIPMethod returns Message method
func (msg *Message) SIPMethod() string { return msg.Method }

// ResponseCode returns SIP response code for ResponseCode or zero
func (msg *Message) ResponseCode() int {
	if !msg.IsResponse() {
		return 0
	}
	code, _ := strconv.Atoi(msg.Code)
	return code
}

// IsProvisional returns true if message is Response and
// response code is between 100 and 199
func (msg *Message) IsProvisional() bool { return msg.codePrefix('1') }

// IsFinalResponse returns true if response code is any of 2xx, 3xx, 4xx, 5xx or 6xx
func (msg *Message) IsFinalResponse() bool {
	for _, c := range []byte("23456") {
		if msg.codePrefix(c) {
			return true
		}
	}
	return false
}

func (msg *Message) SetViaTransp(transp string, laddr net.Addr) error {
	via := msg.TopVia()
	if via == nil {
		return fmt.Errorf("%w: no top Via header found", Error)
	}

	if laddr == nil {
		return fmt.Errorf("%w: invalid local address to set in top Via", Error)
	}

	host, port, err := net.SplitHostPort(laddr.String())
	if err != nil {
		return fmt.Errorf("%w: failed to get host and port for top Via: %s",
			Error, err)
	}

	via.Transp = transp
	via.Host = host
	via.Port = port

	return nil
}

// TopViaBranch returns top Via header branch parameter
func (msg *Message) TopViaBranch() string {
	if via := msg.TopVia(); via != nil {
		return via.Branch
	}

	return ""
}

// TopVia returns first, top Via header
func (msg *Message) TopVia() *HeaderVia {
	hdr := msg.Find(HVia)
	if hdr == nil {
		return nil
	}
	via, ok := hdr.(*HeaderVia)
	if !ok {
		return nil
	}
	return via
}

// ACK returns ACK message generated from initial request
// This ACK request is a part of transaction machine
// and generated on any responses other then 200
// ACK for 200 responses are generated by TU/UA level
//
// 17.1.1.3 Construction of the ACK Request
// ACK is supposed to be generated from initial request
func (msg *Message) ACK(resp *Message) *Message {
	ack := NewMessage()
	ack.t = HRequest
	ack.Method = "ACK"
	ack.RURI = msg.RURI

	if topVia := msg.Find(HVia); topVia != nil {
		// The ACK MUST contain a single Via header field, and
		// this MUST be equal to the top Via header field of the original
		// request.

		if via, ok := topVia.(*HeaderVia); ok {
			viacopy := via.copy()
			viacopy.Next = nil // remove linked Via if exist
			ack.Append(HGeneric, viacopy)
		}
	}

	ack.MaxFwd = 70
	ack.Append(HGeneric, &HeaderGeneric{T: HMaxForwards, HeaderName: "Max-Forwards", Value: "70"})

	for _, r := range msg.FindAll(HRoute) {
		ack.Append(HGeneric, r.Copy())
	}

	ack.From = msg.From.copy()
	ack.Append(HGeneric, ack.From)

	ack.To = resp.To.copy()
	ack.Append(HGeneric, ack.To)

	ack.CallID = msg.CallID
	ack.Append(HGeneric, &HeaderGeneric{T: HCallID, HeaderName: "Call-ID", Value: msg.CallID})

	ack.CSeq = msg.CSeq
	ack.Append(HGeneric, &HeaderGeneric{T: HCSeq, HeaderName: "CSeq", Value: strconv.Itoa(msg.CSeq) + " ACK"})

	ack.Append(HGeneric, &HeaderGeneric{T: HContentLength, HeaderName: "Content-Length", Value: "0"})

	return ack
}

// Response creates SIP response message with given code and reason
// message and setup headers as it defines in rfc3261#8.2.6.2
func (msg *Message) Response(code int, reason string) *Message {
	res := NewMessage()
	res.t = HResponse
	res.Method = msg.Method
	res.Code = strconv.Itoa(code)
	res.Reason = reason

	// copy headers

	for _, via := range msg.FindAll(HVia) {
		res.Append(HGeneric, via.Copy())
	}

	// just copy To header and let UA to append Tag if needed
	res.To = msg.To.copy()
	res.Append(HGeneric, res.To)

	res.From = msg.From.copy()
	res.Append(HGeneric, res.From)

	res.CallID = msg.CallID
	res.Append(HGeneric, &HeaderGeneric{T: HCallID, HeaderName: "Call-ID", Value: msg.CallID})

	res.CSeq = msg.CSeq
	res.Append(HGeneric, &HeaderGeneric{T: HCSeq, HeaderName: "CSeq", Value: strconv.Itoa(msg.CSeq) + " ACK"})

	return res
}

// Append SIP Header to Message. Will search for the first accurence
// of t type header and append header after. If t is HGeneric or
// header not found then append to the last header
func (msg *Message) Append(t HType, hdr AnyHeader) {
	msg.push(t, hdr,
		func() []AnyHeader { return append(msg.Headers, hdr) },
		func(i int) int { return i + 1 })
}

// Insert SIP Header to Message. Will search for the first accurence
// of t type header and insert header before it. If t is HGeneric or
// header not found then insert to the top
func (msg *Message) Insert(t HType, hdr AnyHeader) {
	msg.push(t, hdr,
		func() []AnyHeader { return slices.Insert(msg.Headers, 0, hdr) },
		func(i int) int { return i })
}

func (msg *Message) push(t HType, hdr AnyHeader, gen func() []AnyHeader, index func(int) int) {
	if t == HGeneric {
		msg.Headers = gen()
		return
	}

	for i, h := range msg.Headers {
		if h.Type() == t {
			msg.Headers = slices.Insert(msg.Headers, index(i), hdr)
			return
		}
	}

	// not found
	msg.Headers = gen()
}

// HLen returns number of headers in the SIP message
func (msg *Message) HLen() int { return msg.Headers.Len() }

// Find first occurrense of a header by HType
func (msg *Message) Find(t HType) AnyHeader {
	return msg.find(func(h AnyHeader) bool { return h.Type() == t })
}

// FindAll find and return list of headers by type
func (msg *Message) FindAll(t HType) Headers {
	return msg.findAll(func(h AnyHeader) bool { return h.Type() == t })
}

// FindByName first occurrense of a header by name
func (msg *Message) FindByName(name string) AnyHeader {
	return msg.find(func(h AnyHeader) bool { return h.Name() == name })
}

// FindByNameAll find and return list of headers by name
func (msg *Message) FindByNameAll(name string) Headers {
	return msg.findAll(func(h AnyHeader) bool { return h.Name() == name })
}

// FirstLine SIP message request or response first line
// handy for logs and debugging
func (msg *Message) FirstLine() string {
	buf := NewStringer(msg.firstLineLen())
	msg.firstLine(buf)
	return buf.String()
}

// Len length of SIP message in bytes
func (msg *Message) Len() int {
	crln := 2
	l := msg.firstLineLen()
	l += crln

	for _, hdr := range msg.Headers {
		l += hdr.Len() + crln
	}
	return l + crln + len(msg.Body)
}

// DelHeader remove from message all headers with name
func (msg *Message) DelHeader(name string) {
	msg.Headers = slices.DeleteFunc(msg.Headers, func(h AnyHeader) bool {
		return h.Name() == name
	})
}

// String return Message as string
func (msg *Message) String() string {
	buf := NewStringer(msg.Len())

	msg.firstLine(buf)

	for _, hdr := range msg.Headers {
		hdr.Stringify(buf)
		buf.Print("\r\n")
	}

	buf.Print("\r\n", msg.Body)

	return buf.String()
}

func (msg *Message) codePrefix(c byte) bool {
	if len(msg.Code) == 0 {
		return false
	}
	return msg.Code[0] == c
}

func (msg *Message) firstLine(buf *Stringer) {
	if msg.IsResponse() {
		buf.Print("SIP/2.0 ", msg.Code, " ", msg.Reason, "\r\n")
		return
	}
	buf.Print(msg.Method, " ")
	msg.RURI.Stringify(buf)
	buf.Print(" SIP/2.0\r\n")
}

func (msg *Message) firstLineLen() int {
	ver := 9 // "SIP/2.0" + spaces
	if msg.t == HRequest {
		return ver + len(msg.Method) + msg.RURI.Len()
	}
	return len(msg.Code) + len(msg.Reason) + ver
}

func (msg *Message) find(match func(h AnyHeader) bool) AnyHeader {
	for _, h := range msg.Headers {
		if match(h) {
			return h
		}
	}
	return nil
}

func (msg *Message) findAll(match func(h AnyHeader) bool) Headers {
	list := make(Headers, 0)
	for _, h := range msg.Headers {
		if match(h) {
			list = append(list, h)
		}
	}
	return list
}

func (msg *Message) pushHeader(t HType, name, value string) {
	generic := &HeaderGeneric{
		T:          t,
		HeaderName: name,
		Value:      value,
	}
	msg.Headers = append(msg.Headers, generic)
}
